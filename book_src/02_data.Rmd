# Data


```{r setup_02, include=FALSE}
pkgs <- sort(c('tidyverse', 'GGally', 'plotly', 'factoextra', 'arules', 
  'seriation', 'sampling', 'caret', 'proxy'))

lapply(pkgs, function(pkg) {
  if (system.file(package = pkg) == '') install.packages(pkg)
})

all_pkgs <- union(all_pkgs, pkgs)
```

**Packages used for this chapter:** `r format_pkgs(pkgs)`

## The Iris Dataset

We will use a toy dataset that comes with R. [Fisher's iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.
For more details see: `? iris`

Load the iris data set and convert the data.frame into a tibble. _Note:_ datasets that come with R or R packages can be loaded with `data()`.

```{r }
library(tidyverse)
data(iris)
iris <- as_tibble(iris)
iris
```

## Data Quality
Inspect data (produce a scatterplot matrix using `ggpairs` from package `GGally`). Possibly
you can see noise and ouliers.

```{r }
library(GGally)
ggpairs(iris, aes(color = Species))
```

Get summary statistics for each column (outliers, missing values)

```{r }
summary(iris)
```

just the mean

```{r }
iris %>% summarize_if(is.numeric, mean)
```

Often you will do something
like:

```{r }
clean.data <- iris %>% drop_na() %>% unique()
summary(clean.data)
```

Note that one case (non-unique) is gone. All cases with missing
values will also have been dropped.

## Aggregation
Aggregate by species. First group the data and then summarize each group.

```{r }
iris %>% group_by(Species) %>% summarize_all(mean)
iris %>% group_by(Species) %>% summarize_all(median)
```


## Sampling
### Random Sampling

Sample from a vector with replacement.

```{r }
sample(c("A", "B", "C"), size = 10, replace = TRUE)
```

Sampling rows from a tibble (I set the random number generator seed to make the results reproducible).

```{r }
set.seed(1000)

s <- iris %>% sample_n(15)
ggpairs(s, aes(color = Species))
```

### Stratified Sampling

[Stratified sampling](https://en.wikipedia.org/wiki/Stratified_sampling)
 is a method of sampling from a population which can be partitioned into subpopulations,
 while controlling the proportions of the subpopulation in the resulting sample.

 In the following, the subpopulations are the different types of species and we want
 to make sure to sample the same number (5) flowers from each.

You need to install the package sampling with:
install.packages("sampling")

```{r }
library(sampling)
id2 <- strata(iris, stratanames="Species", size=c(5,5,5), method="srswor")
id2

s2 <- iris %>% slice(id2$ID_unit)
ggpairs(s2, aes(color = Species))
```

## Features
### Dimensionality Reduction

#### Principal Components Analysis (PCA)

[PCA](https://en.wikipedia.org/wiki/Principal_component_analysis) calculates principal components (a new orthonormal basis vectors in the data space) from data points such that the first principal component explains the most variability in the data, the second the next most and so on.
In data analysis, PCA is used to project high-dimensional data points onto the first few (typically two) principal components for visualization as a scatter plot and as preprocessing for modeling (e.g., before k-means clustering).
Points that are closer together in the high-dimensional space, tend also be closer together in the lower-dimensional space,

Look at the 3d data using an interactive 3d plot (needs package plotly). However, 3d plots are hard to print out and the iris data is actually in 4 dimensions.

```{r }
##library(plotly) # I don't load the package because it's namespace clashes with select in dplyr.
plotly::plot_ly(iris, x = ~Sepal.Length, y = ~Petal.Length, z = ~Sepal.Width,
  size = ~Petal.Width, color = ~Species, type="scatter3d")
```

Calculate the principal components using `prcomp()`

```{r }
pc <- iris %>% select(-Species) %>% as.matrix() %>% prcomp()
summary(pc)
```

How important is each principal component can also be seen using a [scree plot](https://en.wikipedia.org/wiki/Scree_plot). The plot shows how much variability in the data is explained by each additional principal component.

```{r }
plot(pc, type = "line")
```

__Note:__ For the iris data, the first principal component (PC1) explains most of the variability in the data.

Inspect the raw object (display *str*ucture)

```{r }
str(pc)
```

We can display the data points projected on the first two principal components.

```{r }
ggplot(as_tibble(pc$x), aes(x = PC1, y = PC2, color = iris$Species)) + geom_point()
```

Since the first principal component represents most of the variability, we can
also project the data only on PC1.

```{r }
ggplot(as_tibble(pc$x), aes(x = PC1, y = 0, color = iris$Species)) + geom_point()
```

Plot the projected data and add the original axes as arrows. This is called a
[biplot](https://en.wikipedia.org/wiki/Biplot). If old and new axes point roughly in the
same direction, then they are correlated (linearly dependent).

```{r }
library(factoextra)
fviz_pca(pc)
fviz_pca_var(pc)
```

Another popular method to project data in lower dimensions for visualization is __t-distributed stochastic neighbor embedding (t-SNE)__ available in package `Rtsne`.

#### Multi-Dimensional Scaling (MDS)

[MDS](https://en.wikipedia.org/wiki/Multidimensional_scaling) is similar to PCA. Instead of data points, it takes pairwise distances (i.e., a distance matrix) and produces a space where points are placed to represent these distances as well as possible. The axis in this space are called components and are similar to the principal components in PCA. Let's calculate
distances in the 4-d space of iris.

```{r }
d <- iris %>% select(-Species) %>% dist()
```

and do metric (classic) MDS to reconstruct a 2-d space.

```{r }
fit <- cmdscale(d, k = 2)
colnames(fit) <- c("comp1", "comp2")
fit <- as_tibble(fit)

ggplot(fit, aes(x = comp1, y = comp2, color = iris$Species)) + geom_point()
```

#### Non-Parametric Multidimensional Scaling

Non-parametric multidimensional scaling performs MDS while relaxing the need of linear relationships. Methods are available in package `MASS` as functions
`isoMDS` and `sammon`.

### Feature Selection

We will talk about feature selection when we discuss [classification models](chap3.html#feature-selection-and-feature-preparation).

### Discretize Features

```{r }
ggplot(iris, aes(x = Petal.Width, y = 1:150)) + geom_point()
```

A histogram is a better visualization for the distribution of a single
variable.

```{r }
ggplot(iris, aes(Petal.Width)) + geom_histogram()
```

Equal interval width

```{r }
iris %>% pull(Sepal.Width) %>% cut(breaks=3)
```

Other methods (equal frequency, k-means clustering, etc.)

```{r }
library(arules)
iris %>% pull(Petal.Width) %>% discretize(method = "interval", breaks = 3)
iris %>% pull(Petal.Width) %>% discretize(method = "frequency", breaks = 3)
iris %>% pull(Petal.Width) %>% discretize(method = "cluster", breaks = 3)

ggplot(iris, aes(Petal.Width)) + geom_histogram() +
  geom_vline(xintercept =
      iris %>% pull(Petal.Width) %>% discretize(method = "interval", breaks = 3, onlycuts = TRUE),
    color = "blue") +
  labs(title = "Discretization: interval", subtitle = "Blue lines are boundaries")

ggplot(iris, aes(Petal.Width)) + geom_histogram() +
  geom_vline(xintercept =
      iris %>% pull(Petal.Width) %>% discretize(method = "frequency", breaks = 3, onlycuts = TRUE),
    color = "blue") +
  labs(title = "Discretization: frequency", subtitle = "Blue lines are boundaries")

ggplot(iris, aes(Petal.Width)) + geom_histogram() +
  geom_vline(xintercept =
      iris %>% pull(Petal.Width) %>% discretize(method = "cluster", breaks = 3, onlycuts = TRUE),
    color = "blue") +
  labs(title = "Discretization: cluster", subtitle = "Blue lines are boundaries")
```

### Standardize Data (Z-Scores)

Standardize the scale of features to make them comparable. For each
column the mean is subtracted (centering) and it is divided by the
standard deviation (scaling). Now most values should be in [-3,3].

_Note:_ tidyverse currently does not have a simple scale function,
so I make one that provides a wrapper for the standard scale function in R:

```{r }
scale_numeric <- function(x) x %>% mutate_if(is.numeric, function(y) as.vector(scale(y)))

iris.scaled <- iris %>% scale_numeric()
iris.scaled
summary(iris.scaled)
```

## Proximities: Similarities and Distances

__Note:__ R actually only uses dissimilarities/distances.

### Minkowsky Distances

The [Minkowsky distance](https://en.wikipedia.org/wiki/Minkowski_distance) is a family of
metric distances including Euclidean and Manhattan distance.

```{r }
iris_sample <- iris.scaled %>% select(-Species) %>% slice(1:5)
iris_sample
```

Calculate distances matrices between the first 5 flowers (use only the 4 numeric columns).

```{r }
iris_sample %>% dist(method="euclidean")
iris_sample %>% dist(method="manhattan")
iris_sample %>% dist(method="maximum")
```

__Note:__ Don't forget to scale the data if the ranges are very different!

### Distances for Binary Data

```{r }
b <- rbind(
  c(0,0,0,1,1,1,1,0,0,1),
  c(0,0,1,1,1,0,0,1,0,0)
  )
b
```

#### Jaccard Index

[Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) is a similarity measure so R reports 1-Jaccard

```{r }
b %>% dist(method = "binary")
```

#### Hamming Distance

[Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) is the number of mis-matches (equivalent to
Manhattan distance on 0-1 data and also the squared Euclidean distance).

```{r }
b %>% dist(method = "manhattan")

b %>% dist(method = "euclidean") %>% "^"(2)
```

_Note_: `"^"(2)` calculates the square.

### Distances for Mixed Data

#### Gower's Distance

Works with mixed data

```{r }
data <- tibble(
  height= c(      160,    185,    170),
  weight= c(       52,     90,     75),
  sex=    c( "female", "male", "male")
)
data
```

__Note:__ Nominal variables need to be factors!

```{r }
data <- data %>% mutate_if(is.character, factor)
data

library(proxy)
d_Gower <- data %>% dist(method="Gower")
d_Gower
```

__Note:__ Gower's distance automatically scales, so no need to scale
the data first.

#### Using Euclidean Distance with Mixed Data

Sometimes methods (e.g., k-means) only can use Euclidean distance. In this
case, nominal features can be converted into 0-1 dummy variables. Euclidean
distance on these will result in a usable distance measure.

Create dummy variables

```{r }
library(caret)
data_dummy <- dummyVars(~., data) %>% predict(data)
data_dummy
```

Since sex has now two columns, we need to weight them by 1/2 after scaling.

```{r }
weight <- matrix(c(1,1,1/2,1/2), ncol = 4, nrow = nrow(data_dummy), byrow = TRUE)
data_dummy_scaled <- scale(data_dummy) * weight

d_dummy <- data_dummy_scaled %>% dist()
d_dummy
```

Distance is (mostly) consistent with Gower's distance (other than that
Gower's distance is scaled between 0 and 1).

```{r }
ggplot(tibble(d_dummy, d_Gower), aes(x = d_dummy, y = d_Gower)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

### Additional proximity Measures Available in Package proxy

```{r }
library(proxy)
pr_DB$get_entries() %>% names()
```

## Relationships Between Features
### Correlation 
Correlation can be used for 
ratio/interval scaled features.
We typically think of the [Pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient) between features (columns).

```{r }
cc <- iris %>% select(-Species) %>% cor()

ggplot(iris, aes(Petal.Length, Petal.Width)) + geom_point() +
  geom_smooth(method = "lm")
with(iris, cor(Petal.Length, Petal.Width))
```

_Note:_ `with` is the same as `cor(iris$Petal.Length, iris$Petal.Width)`

```{r }
with(iris, cor.test(Petal.Length, Petal.Width))

ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point() +
  geom_smooth(method = "lm")
with(iris, cor(Sepal.Length, Sepal.Width))
with(iris, cor.test(Sepal.Length, Sepal.Width))
```

### Rank Correlation 

Rank correlation is used for ordinal features.
To show this, we first convert the continuous features in Iris into
ordered factors with three levels using the function `cut`.

```{r }
iris_ord <- iris %>% mutate_if(is.numeric,
  function(x) cut(x, 3, labels = c("short", "medium", "long"), ordered = TRUE))

iris_ord
summary(iris_ord)
iris_ord %>% pull(Sepal.Length)
```

Kendall's tau rank correlation coefficient

```{r }
iris_ord %>% select(-Species) %>% sapply(xtfrm) %>% cor(method="kendall")
```

Spearman's rho

```{r }
iris_ord %>% select(-Species) %>% sapply(xtfrm) %>% cor(method="spearman")
```

__Note:__ unfortunately we have to transform the ordered factors
into numbers representing the order with xtfrm first.

Compare to the Pearson correlation on the original data

```{r }
iris %>% select(-Species) %>% cor()
```

### Relationship Between Nominal and Ordinal Features
Is sepal length and species related? Use cross tabulation

```{r }
tbl <- iris_ord %>% select(Sepal.Length, Species) %>% table()
tbl
```

Doing this with tidyverse is a little more involved and uses pivot operations and grouping.
```{r }
iris_ord %>%
  select(Species, Sepal.Length) %>%
  pivot_longer(cols = Sepal.Length) %>%
  group_by(Species, value) %>% count() %>% ungroup() %>%
  pivot_wider(names_from = Species, values_from = n)
```

Test of Independence: Pearson's chi-squared test is performed with the null hypothesis that the joint distribution of the cell counts in a 2-dimensional contingency table is the product of the row and column marginals. (h0 is independence)

```{r }
tbl %>% chisq.test()
```

Using xtabs instead

```{r }
x <- xtabs(~Sepal.Length + Species, data = iris_ord)
x
summary(x)
```

Group-wise averages

```{r }
iris %>% group_by(Species) %>% summarize_at(vars(Sepal.Length), mean)
iris %>% group_by(Species) %>% summarize_all(mean)
```

## Density Estimation

[Density estimation](https://en.wikipedia.org/wiki/Density_estimation) constructions an estimate of an unobservable probability density function (a distribution) based on observed data.

Just plotting the data is not very helpful

```{r }
ggplot(iris, aes(Petal.Length, 1:150)) + geom_point()
```

Histograms work better

```{r }
ggplot(iris, aes(Petal.Length)) +
  geom_histogram() +
  geom_rug(alpha = 1/10)
```


Kernel density estimate KDE

```{r }
ggplot(iris, aes(Petal.Length)) +
  geom_rug(alpha = 1/10) +
  geom_density()
```

Plot 2d kernel density estimate

```{r }
ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_jitter() +
  geom_density2d()

ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_bin2d(bins = 10) +
  geom_jitter(color = "red")

ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_hex(bins = 10) +
  geom_jitter(color = "red")
```

## Exploring Data

### Basic statistics

Load the iris data set.

```{r }
data(iris)
```

[Fisher's iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.

We convert the data.frame into a tidyerse tibble. This is optional, tidyverse can work directly with data.frames.

```{r }
iris <- as_tibble(iris)

iris
```


Get summary statistics (using base R)

```{r }
summary(iris)
```

Get mean and standard deviation for sepal length

```{r }
iris %>% pull(Sepal.Length) %>% mean()
iris %>% pull(Sepal.Length) %>% sd()
```

Ignore missing values (Note: this data does not contain any, but this is
what you would do)

```{r }
iris %>% pull(Sepal.Length) %>% mean(na.rm = TRUE)
```

Robust mean (trim 10% of observations from each end of the distribution)

```{r }
iris %>% pull(Sepal.Length) %>% mean(trim = .1)
```

Calculate a summary for all numeric columns

```{r }
iris %>% summarize_if(is.numeric, mean)
iris %>% summarize_if(is.numeric, sd)

iris %>% summarize_if(is.numeric, list(min = min, median = median, max = max))
```

MAD (median absolute deviation)

```{r }
iris %>% summarize_if(is.numeric, mad)
```

### Tabulate data

Count the different species.

```{r }
iris %>% count(Species)
```

Discretize the data first since there are too many values (cut divides the range by breaks, see package discretization for other methods)

```{r }
iris_discrete <- iris %>% mutate_if(is.numeric,
  function(x) cut(x, 3, labels = c("short", "medium", "long"), ordered = TRUE))

iris_discrete
summary(iris_discrete)
```

Create some tables (creating tables is a little harder using tidyverse)

```{r }
iris_discrete %>% select(Sepal.Length, Sepal.Width) %>% table()
iris_discrete %>% select(Petal.Length, Petal.Width) %>% table()
iris_discrete %>% select(Petal.Length, Species) %>% table()
```

Test if the two features are independent given the counts in the
contingency table (H0: independence)

p-value: the probability of seeing a more extreme value of the test
statistic under the assumption that H0 is correct. Low p-values (typically
less than .05 or .01) indicate that H0 should be rejected.

```{r }
tbl <- iris_discrete %>% select(Sepal.Length, Sepal.Width) %>% table()
tbl
chisq.test(tbl)
```

Fisher's exact test is  better for small counts (cells with counts <5)

```{r }
fisher.test(tbl)
```

Look at the distribution for a discrete variable

```{r }
iris_discrete %>% count(Sepal.Length)
```

### Percentiles (Quantiles)

By default calculates quantiles

```{r }
iris %>% pull(Petal.Length) %>% quantile()
```

Interquartile range

```{r }
iris %>% summarize(IQR = quantile(Petal.Length, probs = 0.75) - quantile(Petal.Length, probs = 0.25))
```

## Visualization


### Histogram

Show the distribution of a single numeric variable

```{r }
ggplot(iris, aes(Petal.Width)) + geom_histogram(bins = 20)
```

### Boxplot

Compare the distribution of a variable between different groups.

```{r }
ggplot(iris, aes(Species, Sepal.Length)) + geom_boxplot()
```

Group-wise averages

```{r }
iris %>% group_by(Species) %>% summarize_if(is.numeric, mean)
```

To compare the distribution of the four features using a ggplot boxplot,
we first have to transform the data into long format (i.e., all feature values are combined into a single column).

```{r }
library(tidyr)
iris_long <- iris %>% mutate(id = row_number()) %>% pivot_longer(1:4)
ggplot(iris_long, aes(name, value)) + geom_boxplot()
```

### Scatter plot

Show the relationship between two numeric variables

```{r }
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point()
```

### Scatter Plot Matrix

Show the relationship between several numeric variables

```{r }
library("GGally")
ggpairs(iris,  aes(color = Species))
```

### Data Matrix Visualization

We need the long format

```{r }
iris_long <- iris %>% mutate(id = row_number()) %>% pivot_longer(1:4)
head(iris_long)

ggplot(iris_long,
  aes(x = name, y = id, fill = value)) + geom_tile() +
  scale_fill_viridis_c()
```

values smaller than the average are blue and larger ones are red

```{r }
iris_scaled <- iris %>% select(-Species) %>% scale()
iris_scaled_long <- iris_scaled %>% as_tibble() %>%
  mutate(id = row_number()) %>% pivot_longer(cols = 1:4)

ggplot(iris_scaled_long,
  aes(x = name, y = id, fill = value)) + geom_tile() +
  scale_fill_gradient2()
```

Reorder

```{r }
library(seriation)
iris_scaled_matrix <- as.matrix(iris_scaled)
o <- seriate(iris_scaled_matrix)
iris_ordered <- permute(iris_scaled_matrix, o)
iris_ordered_long <- iris_ordered %>% as_tibble %>%
  mutate(id = row_number()) %>% pivot_longer(cols = 1:4)

ggplot(iris_ordered_long,
  aes(x = name, y = id, fill = value)) + geom_tile() +
  scale_fill_gradient2()
```

### Correlation Matrix

Calculate and visualize the correlation between features

```{r }
cm1 <- iris %>% select(-Species) %>% as.matrix %>% cor()
cm1

library(ggcorrplot)
ggcorrplot(cm1)
```

use hmap from package seriation

```{r }
hmap(cm1, margin = c(7,7), cexRow = 1, cexCol = 1)
```

Test if correlation is significantly different from 0

```{r }
cor.test(iris$Sepal.Length, iris$Sepal.Width)
cor.test(iris$Petal.Length, iris$Petal.Width) #this one is significant
```

Correlation between objects

```{r }
cm2 <- iris %>% select(-Species) %>% as.matrix() %>% t() %>% cor()

ggcorrplot(cm2)
```

### Parallel Coordinates Plot

```{r }
library(GGally)
ggparcoord(as_tibble(iris), columns = 1:4, groupColumn = 5)
```

Reorder with placing correlated features next to each other

```{r }
library(seriation)
o <- seriate(as.dist(1-cor(iris[,1:4])), method="BBURCG")
get_order(o)
ggparcoord(as_tibble(iris), columns = get_order(o), groupColumn = 5)
```

Look at https://www.r-graph-gallery.com/ for many example graphs.

